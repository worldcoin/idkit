<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IDKit Browser Example</title>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --button-bg: #333;
        --button-text: #e0e0e0;
        --section-bg: #252525;
        --border-color: #444;
      }

      [data-theme="light"] {
        --bg-color: #ffffff;
        --text-color: #1a1a1a;
        --button-bg: #f0f0f0;
        --button-text: #1a1a1a;
        --section-bg: #f5f5f5;
        --border-color: #ddd;
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        padding: 20px;
        transition:
          background-color 0.3s,
          color 0.3s;
      }

      button {
        background-color: var(--button-bg);
        color: var(--button-text);
        border: 1px solid var(--border-color);
        padding: 10px 16px;
        border-radius: 6px;
        cursor: pointer;
        margin: 4px;
      }

      button:hover {
        opacity: 0.8;
      }

      section {
        background-color: var(--section-bg);
        padding: 16px;
        border-radius: 8px;
        margin-top: 16px;
        border: 1px solid var(--border-color);
      }

      pre {
        background-color: var(--button-bg);
        padding: 12px;
        border-radius: 4px;
        overflow-x: auto;
      }

      .theme-toggle {
        position: fixed;
        top: 16px;
        right: 16px;
        background: var(--button-bg);
        border: 1px solid var(--border-color);
        color: var(--button-text);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <button
      class="theme-toggle"
      id="themeToggle"
      aria-label="Toggle theme"
    ></button>

    <h1>IDKit Browser Example</h1>
    <p>Minimal example showing World ID verification via the Rust/WASM core.</p>

    <div>
      <button id="verifyOrb">Verify with Orb</button>
      <button id="verifyFace">Verify with Face</button>
      <button id="verifyDevice">Verify with Device</button>
    </div>

    <section id="qr" hidden>
      <h3>Scan with World App</h3>
      <p id="qrUrl"></p>
      <div id="qrCode"></div>
    </section>

    <section id="status" hidden>
      <h3>Status</h3>
      <p id="statusText"></p>
    </section>

    <section id="result" hidden>
      <h3>Verification Successful</h3>
      <pre id="resultData"></pre>
    </section>

    <section id="error" hidden>
      <h3>Error</h3>
      <p id="errorText"></p>
    </section>

    <script>
      // Theme toggle functionality
      const themeToggle = document.getElementById("themeToggle");
      const html = document.documentElement;

      function updateToggleText() {
        const isDark = html.getAttribute("data-theme") !== "light";
        themeToggle.textContent = isDark ? "Light" : "Dark";
      }

      themeToggle.addEventListener("click", () => {
        const isDark = html.getAttribute("data-theme") !== "light";
        html.setAttribute("data-theme", isDark ? "light" : "dark");
        updateToggleText();
      });

      // Initialize toggle text
      updateToggleText();
    </script>

    <script type="module">
      // Import IDKit core (pure TypeScript, no dependencies)
      import { IDKit, orbLegacy, hashSignal } from "@worldcoin/idkit-core";

      // Demo app configuration
      const APP_ID = "app_315057b8441a523e7a9b2416f1262a65"; // Replace with your actual app ID
      const ACTION = "test-action2";

      // UI elements
      const qrDiv = document.getElementById("qr");
      const qrUrl = document.getElementById("qrUrl");
      const qrCode = document.getElementById("qrCode");
      const statusDiv = document.getElementById("status");
      const statusText = document.getElementById("statusText");
      const resultDiv = document.getElementById("result");
      const resultData = document.getElementById("resultData");
      const errorDiv = document.getElementById("error");
      const errorText = document.getElementById("errorText");

      const hideAll = () => {
        qrDiv.hidden = true;
        statusDiv.hidden = true;
        resultDiv.hidden = true;
        errorDiv.hidden = true;
      };

      // Initialize WASM on page load
      await IDKit.init();

      /**
       * Build dev portal verify request from IDKit proof result.
       * Matches response items with their original credential request signals.
       *
       * @param proof - IDKit result from pollForUpdates()
       * @param action - Action identifier
       * @param credentialRequests - Original credential requests (with signals)
       * @param nonce - Nonce from rp_context (for v4)
       */
      function buildPortalVerifyRequest(
        proof,
        action,
        credentialRequests,
        nonce,
      ) {
        const isV4 = proof.protocol_version === "4.0";

        // Create map of identifier -> signal from original credential requests
        const signalMap = new Map();
        for (const req of credentialRequests) {
          if (req.signal) {
            signalMap.set(req.type, hashSignal(req.signal));
          }
        }

        // Default signal hashes
        const defaultV3SignalHash =
          "0x00c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4";
        const defaultV4SignalHash = "0x0";

        if (isV4) {
          const responses = proof.responses.map((r) => ({
            identifier: r.identifier,
            signal_hash: signalMap.get(r.identifier) ?? defaultV4SignalHash,
            issuer_schema_id: r.issuer_schema_id,
            nullifier: r.nullifier,
            nonce: nonce,
            merkle_root: r.merkle_root,
            proof_timestamp: String(r.proof_timestamp),
            // TODO: dev portal expects compressed_proof as [string; 4] array
            compressed_proof: r.proof,
          }));

          return {
            protocol_version: "v4",
            action,
            responses,
          };
        } else {
          const responses = proof.responses.map((r) => ({
            identifier: r.identifier,
            signal_hash: signalMap.get(r.identifier) ?? defaultV3SignalHash,
            merkle_root: r.merkle_root,
            nullifier_hash: r.nullifier_hash,
            proof: r.proof,
          }));

          return {
            protocol_version: "v3",
            action,
            responses,
          };
        }
      }

      // Fetch RP signature from the backend
      async function fetchRpSignature(action) {
        const res = await fetch("/api/rp-signature", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action }),
        });

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || "Failed to fetch RP signature");
        }

        return res.json();
      }

      // Function to verify with World ID using the new IDKit.request().constraints() API
      async function startVerification(credentialType, signal) {
        try {
          hideAll();

          statusDiv.hidden = false;
          statusText.textContent = "Fetching RP signature...";

          // Fetch RP signature from the backend
          const rpSig = await fetchRpSignature(ACTION);
          console.log("RP signature response:", rpSig);
          const rpContext = {
            rp_id: "rp_1234567890abcdef", // Valid 16 hex char RP ID
            nonce: rpSig.nonce,
            created_at: rpSig.created_at,
            expires_at: rpSig.expires_at,
            signature: rpSig.sig,
          };
          console.log("RP context:", rpContext);

          statusText.textContent = "Creating verification request...";

          // Store credential requests for later use
          const credentialRequests = [{ type: credentialType, signal }];

          // Create a new request using the builder pattern
          const request = await IDKit.request({
            app_id: APP_ID,
            action: ACTION,
            rp_context: rpContext,
          }).preset(orbLegacy({ signal }));

          // Get the connector URL from the request
          const url = request.connectorURI.replace(
            "https://world.org/verify",
            "https://stage.world.org/verify",
          );
          console.log("Connect URL:", url);

          qrDiv.hidden = false;
          qrUrl.textContent = url;

          qrCode.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(url)}" alt="QR Code">`;

          statusText.textContent = "Waiting for scan...";

          // Poll for updates until proof is received
          const proof = await request.pollForUpdates({
            pollInterval: 2000, // Poll every 2 seconds
            timeout: 120000, // 2 minute timeout
          });

          // Build portal request and verify proof
          statusText.textContent = "Verifying proof...";
          const portalRequest = buildPortalVerifyRequest(
            proof,
            ACTION,
            credentialRequests,
            rpContext.nonce,
          );

          const verifyResponse = await fetch("/api/verify-proof", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              rp_id: APP_ID,
              portalRequest,
            }),
          });

          const verifyResult = await verifyResponse.json();

          statusDiv.hidden = true;
          qrDiv.hidden = true;
          resultDiv.hidden = false;
          resultData.textContent = JSON.stringify(
            { proof, verification: verifyResult },
            null,
            2,
          );
        } catch (error) {
          console.error("Verification error:", error);
          hideAll();
          errorDiv.hidden = false;
          errorText.textContent = error.message;
        }
      }

      // Helper to create a signal with timestamp
      const makeSignal = () => "demo-signal-" + Date.now();

      // Button event listeners
      document
        .getElementById("verifyOrb")
        .addEventListener("click", () =>
          startVerification("orb", makeSignal()),
        );
      document
        .getElementById("verifyFace")
        .addEventListener("click", () =>
          startVerification("face", makeSignal()),
        );
      document
        .getElementById("verifyDevice")
        .addEventListener("click", () =>
          startVerification("device", makeSignal()),
        );
    </script>
  </body>
</html>
