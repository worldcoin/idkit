# IDKit Swift

Swift bindings for IDKit - World ID verification SDK built with Rust and UniFFI.

## Architecture

This Swift SDK is a thing wrapper over the Rust core:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Rust Core (idkit-core)            â”‚
â”‚   - All business logic              â”‚
â”‚   - Session management              â”‚
â”‚   - Constraints                     â”‚
â”‚   - Verification                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ UniFFI
            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Generated Swift                   â”‚
â”‚   - Session, Request, Signal        â”‚
â”‚   - CredentialType, Constraints     â”‚
â”‚   - Status, Proof                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Installation

### Swift Package Manager

```swift
dependencies: [
    .package(url: "https://github.com/worldcoin/idkit", from: "3.0.0")
]
```

## Quick Start

### Basic Verification

```swift
import IDKit

// Create signal and request
let signal = Signal.fromString(s: "user_12345")
let request = Request(credentialType: .orb, signal: signal)

// Create session
let session = try Session.create(
    appId: "app_staging_123abc",
    action: "vote",
    requests: [request]
)

// Display QR code
print("Scan: \(session.connectUrl())")

for try await status in session.status() {
    switch status {
    case .waitingForConnection:
        print("â³ Waiting for user...")
    case .awaitingConfirmation:
        print("ðŸ“± Awaiting confirmation...")
    case .confirmed(let proof):
        print("âœ… Verified! Nullifier: \(proof.nullifierHash)")
        break
    case .failed(let error):
        fatalError("Verification failed: \(error)")
    }
}
```

### Status Polling

```swift
for try await status in session.status() {
    switch status {
    case .waitingForConnection:
        print("â³ Waiting for user...")
    case .awaitingConfirmation:
        print("ðŸ“± User is confirming...")
    case .confirmed(let proof):
        print("âœ… Verified! \(proof)")
        return
    case .failed(let error):
        fatalError("Verification failed: \(error)")
    }
}
```

### Using Verification Level

```swift
let session = try Session.fromVerificationLevel(
    appId: "app_staging_123abc",
    action: "login",
    verificationLevel: .orb,
    signal: "session_token"
)
```

### Multiple Requests with Constraints

```swift
let signal = Signal.fromString(s: "user_signal")

// Create multiple requests
let orbRequest = Request(credentialType: .orb, signal: signal)
let faceRequest = Request(credentialType: .face, signal: signal)

// User must have at least one (priority: Orb > Face)
let constraints = Constraints.any(credentials: [.orb, .face])

let session = try Session.createWithOptions(
    appId: "app_staging_123abc",
    action: "secure-action",
    requests: [orbRequest, faceRequest],
    actionDescription: "Verify your identity",
    constraints: constraints,
    bridgeUrl: nil
)
```

### Face Authentication

```swift
let signal = Signal.fromString(s: "sensitive_action")
let request = Request(credentialType: .orb, signal: signal)
    .withFaceAuth(faceAuth: true)

let session = try Session.create(
    appId: "app_staging_123abc",
    action: "transfer-funds",
    requests: [request]
)
```

### ABI-Encoded Signals

```swift
let abiSignal = Signal.fromAbiEncoded(bytes: [0x00, 0x01, ...])
let request = Request(credentialType: .orb, signal: abiSignal)
```

## API Reference

### Core Types (Generated from Rust)

All core types are generated by UniFFI from the Rust implementation. This ensures 100% consistency.

#### `Session`

**Static Methods:**
- `create(appId:action:requests:)` - Create session
- `createWithOptions(appId:action:requests:actionDescription:constraints:bridgeUrl:)` - Full options
- `fromVerificationLevel(appId:action:verificationLevel:signal:)` - Convenience method

- **Instance Methods:**
- `pollForStatus() -> Status` - Poll for status (blocking)
- `connectUrl() -> String` - Get connection URL
- `requestId() -> String` - Get request ID

#### `Request`

**From Rust:**
- `Request(credentialType:signal:)` - Create request
- `withFaceAuth(faceAuth:) -> Request` - Add face auth

#### `Signal`

- `Signal.fromString(s:) -> Signal` - From UTF-8 string
- `Signal.fromAbiEncoded(bytes:) -> Signal` - From ABI bytes
- `asBytes() -> Data` - Get bytes as Data
- `asString() -> String?` - Get string (if UTF-8)

#### `Constraints`

- `Constraints.any(credentials:)` - At least one must match
- `Constraints.all(credentials:)` - All must match
- `Constraints.new(root:)` - From constraint node

#### `ConstraintNode`

- `ConstraintNode.credential(credentialType:)` - Leaf node
- `ConstraintNode.any(nodes:)` - OR node
- `ConstraintNode.all(nodes:)` - AND node

#### `Status`

```swift
enum Status {
    case waitingForConnection
    case awaitingConfirmation
    case confirmed(Proof)
    case failed(String)
}
```

#### `Proof`

```swift
struct Proof {
    let proof: String
    let merkleRoot: String
    let nullifierHash: String
    let verificationLevel: CredentialType
}
```

#### `CredentialType`

```swift
enum CredentialType {
    case orb        // Iris biometric
    case face       // Face biometric
    case device     // Device-based
    case secureDocument  // NFC with auth
    case document   // NFC without auth
}
```

#### `VerificationLevel`

```swift
enum VerificationLevel {
    case orb
    case device
    case secureDocument
    case document
}
```

### Errors

All errors are surfaced as `IdkitError` values generated by the Rust core.

## Building from Source

The generated Swift bindings (`swift/Sources/IDKit/Generated/`) are excluded from git and must be regenerated locally.

### Building for all platforms (iOS + macOS)

```bash
# Build Rust library, generate bindings, and create XCFramework
./scripts/package-swift.sh

# Then build the Swift package
cd swift
swift build
```

### For local development with idkit-swift

```bash
# Set up idkit-swift to use local XCFramework
./scripts/setup-local-swift.sh ../idkit-swift

# When done, restore idkit-swift to normal
./scripts/restore-idkit-swift.sh ../idkit-swift
```

### Manual build steps

```bash
# 1. Install Rust targets
rustup target add aarch64-apple-ios-sim x86_64-apple-ios aarch64-apple-ios
rustup target add aarch64-apple-darwin x86_64-apple-darwin

# 2. Build for all platforms
cargo build --release --package idkit-uniffi --target aarch64-apple-ios
cargo build --release --package idkit-uniffi --target aarch64-apple-darwin
# ... (see scripts/package-swift.sh for complete build steps)

# 3. Generate bindings
uniffi-bindgen generate \
    --library target/aarch64-apple-ios-sim/release/libidkit.dylib \
    --language swift \
    --out-dir swift/Sources/IDKit/Generated
```
